<!doctype html>
<html lang="es">

<!-- Mirrored from ead.murciaeduca.es/pluginfile.php/1431894/mod_resource/content/8/AD05_Contenidos_Web/71_tipos_de_objetos.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 15 Sep 2023 20:51:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<link rel="stylesheet" type="text/css" href="../css/base.css" />
<link rel="stylesheet" type="text/css" href="../css/exe_highlighter.css" />
<link rel="stylesheet" type="text/css" href="../css/content.css" />
<link rel="stylesheet" type="text/css" href="../css/nav.css" />
<meta http-equiv="content-type" content="text/html;  charset=utf-8" />
<title>7.1.- Tipos de objetos. </title>
<link rel="shortcut icon" href="../ico/favicon.ico" type="image/x-icon" />
<meta name="generator" content="eXeLearning 2.5 - exelearning.net" />
<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->
<script type="text/javascript" src="../js/exe_jquery.js"></script>
<script type="text/javascript" src="../js/exe_highlighter.js"></script>
<script type="text/javascript" src="../js/common_i18n.js"></script>
<script type="text/javascript" src="../js/common.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" /></head>
<body class="exe-web-site" id="exe-node-22"><script type="text/javascript">document.body.className+=" js"</script>
<div id="content">
<p id="skipNav"><a href="#main" class="sr-av">Saltar la navegación</a></p>
<section id="emptyHeader"></section>
<nav id="siteNav">
<ul>
   <li><a href="index.html" class="daddy main-node">Bases de datos objeto-relacionales y orientadas a objetos.</a></li>
   <li><a href="1_introduccin.html" class="no-ch">1.- Introducción.</a></li>
   <li><a href="2_caractersticas_de_las_bases_de_datos_orientadas_a_objetos.html" class="daddy">2.- Características de las bases de datos orientadas a objetos.</a>
   <ul class="other-section">
      <li><a href="21_ventajas_e_inconvenientes.html" class="no-ch">2.1.- Ventajas e inconvenientes.</a></li>
   </ul>
   </li>
   <li><a href="3_gestores_de_bases_de_datos_orientadas_a_objetos.html" class="daddy">3.- Gestores de bases de datos orientadas a objetos.</a>
   <ul class="other-section">
      <li><a href="31_objetos_simples_y_objetos_estructurados.html" class="no-ch">3.1.- Objetos simples y objetos estructurados.</a></li>
      <li><a href="32_instalacin_del_gestor_de_objetos_db4o.html" class="no-ch">3.2.- Instalación del gestor de objetos Db4o.</a></li>
   </ul>
   </li>
   <li><a href="4_el_api_de_la_base_de_objetos.html" class="daddy">4.- El API de la base de objetos.</a>
   <ul class="other-section">
      <li><a href="41_apertura_y_cierre_de_conexiones.html" class="no-ch">4.1.- Apertura y cierre de conexiones.</a></li>
      <li><a href="42_consultas_a_la_base_de_objetos.html" class="no-ch">4.2.- Consultas a la base de objetos.</a></li>
      <li><a href="43_actualizacin_de_objetos_simples.html" class="no-ch">4.3.- Actualización de objetos simples.</a></li>
      <li><a href="44_actualizacin_de_objetos_estructurados.html" class="no-ch">4.4.- Actualización de objetos estructurados.</a></li>
   </ul>
   </li>
   <li><a href="5_el_lenguaje_de_consulta_de_objetos_oql.html" class="daddy">5.- El lenguaje de consulta de objetos OQL.</a>
   <ul class="other-section">
      <li><a href="51_sintaxis_expresiones_y_operadores.html" class="no-ch">5.1.- Sintaxis, expresiones y operadores.</a></li>
      <li><a href="52_matisse_un_gestor_de_objetos_que_incorpora_oql.html" class="no-ch">5.2.- Matisse, un gestor de objetos que incorpora OQL.</a></li>
      <li><a href="53_ejecucin_de_sentencias_oql.html" class="no-ch">5.3.- Ejecución de Sentencias OQL.</a></li>
      <li><a href="54_ejecucin_de_sentencias_oql_va_jdbc.html" class="no-ch">5.4.- Ejecución de sentencias OQL vía JDBC.</a></li>
   </ul>
   </li>
   <li><a href="6__caractersticas_de_las_bases_de_datos_objetorelacionales.html" class="no-ch">6.-  Características de las bases de datos objeto-relacionales.</a></li>
   <li class="current-page-parent"><a href="7_gestores_de_bases_de_datos_objetorelacionales.html" class="current-page-parent daddy">7.- Gestores de Bases de Datos Objeto-Relacionales.</a>
   <ul>
      <li id="active"><a href="71_tipos_de_objetos.html" class="active no-ch">7.1.- Tipos de objetos.</a></li>
      <li><a href="72_tablas_de_objetos.html" class="no-ch">7.2.- Tablas de objetos</a></li>
      <li><a href="73_referencias_entre_objetos.html" class="no-ch">7.3.- Referencias entre objetos</a></li>
      <li><a href="74_tipos_de_datos_coleccin.html" class="no-ch">7.4.- Tipos de datos colección</a></li>
      <li><a href="75_acceso_a_datos.html" class="no-ch">7.5.- Acceso a datos</a></li>
   </ul>
   </li>
   <li><a href="8_gestin_de_transacciones_en_las_bdor.html" class="no-ch">8.- Gestión de transacciones en las BDOR..</a></li>
   <li><a href="anexo_i_estndar_odmg93__u_odmg.html" class="no-ch">Anexo I.- Estándar ODMG-93  u ODMG.</a></li>
   <li><a href="anexo_licencias_de_recursos.html" class="no-ch">Anexo.- Licencias de recursos.</a></li>
</ul>
</nav>
<div id='topPagination'>
<nav class="pagination noprt">
<a href="7_gestores_de_bases_de_datos_objetorelacionales.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="72_tablas_de_objetos.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
<div id="main-wrapper">
<section id="main">
<header id="nodeDecoration"><h1 id="nodeTitle">7.1.- Tipos de objetos.</h1></header>
<article class="iDevice_wrapper FreeTextfpdIdevice" id="id69">
<div class="iDevice emphasis0">
<div id="ta69_73" class="block iDevice_content">
<p id="yui_3_17_2_1_1596193854839_137" style="text-align: justify;">El modelo relacional está diseñado para representar los datos como una serie de tablas con columnas y atributos. Oracle desde la version 8 , incorpora tecnologías orientadas a objetos. En este sentido, permite construir tipos de objetos complejos, entendidos como:</p>
<ul style="text-align: justify;">
<li> Capacidad para definir objetos dentro de objetos.</li>
<li> Cierta capacidad para encapsular o asociar métodos con dichos objetos.</li>
</ul>
<p style="text-align: justify;"><b> Estructura de un tipo de objeto</b></p>
<p id="yui_3_17_2_1_1596193854839_131" style="text-align: justify;"><span style="font-size: 1.05em;">Un tipo de objeto representa una entidad del mundo real. Encapsula datos y operaciones, por lo que en la especificación sólo se pueden declarar atributos y métodos, pero no constantes, excepciones, cursores o tipos. Al menos un atributo es requerido y los métodos son opcionales. Se compone de los siguientes elementos:</span></p>
<ul style="text-align: justify;">
<li><span>Su nombre que sirve para identificar el tipo de los objetos.</span></li>
<li>Sus atributos que modelan la estructura y los valores de los datos de ese tipo. Cada atributo puede ser de un tipo de datos básico o de un tipo de usuario.</li>
<li><span>Sus métodos (procedimientos o funciones) escritos en lenguaje PL/SQL (almacenados en la </span>BDOR), o escritos en C (almacenados externamente).</li>
</ul>
<p style="text-align: justify;"><span>Los tipos de objetos actúan como plantillas para los objetos de cada tipo. A continuación vemos un </span>ejemplo de cómo definir el tipo de dato Direccion_T en el lenguaje de definición de datos de Oracle, y cómo utilizar este tipo de dato para definir el tipo de dato de los objetos de la clase de Cliente_T.</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent" style="padding-left: 30px;">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE TYPE direccion_t AS OBJECT (
calle VARCHAR2(200),
ciudad VARCHAR2(200),
prov CHAR(2),
codpos VARCHAR2(20));
CREATE TYPE cliente_t AS OBJECT (
clinum NUMBER,
clinomb VARCHAR2(200),
direccion direccion_t,
telefono VARCHAR2(20),
fecha_nac DATE,
MEMBER FUNCTION edad RETURN NUMBER,
PRAGMA
RESTRICT_REFERENCES(edad,WNDS));</code></pre>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span><b>Atributos </b></span><span><br />Como las variables, un atributo se declara mediante un nombre y un tipo. El nombre debe ser único dentro del tipo de objeto (aunque puede reutilizarse en otros objetos) y el tipo puede ser cualquier tipo de Oracle excepto:<br /><br /></span></p>
<ul style="text-align: justify;">
<li>LONG y LONG RAW.</li>
<li>NCHAR, NCLOB y NVARCHAR2.</li>
<li>MLSLABEL y ROWID.</li>
<li>Los tipos específicos de PL/SQL: BINARY_INTEGER (y cualquiera de sus subtipos), BOOLEAN, PLS_INTEGER, RECORD, REF CURSOR, %TYPE y %ROWTYPE.</li>
<li>Los tipos definidos en los paquetes PL/SQL.</li>
</ul>
<p style="text-align: justify;"><span>Tampoco se puede inicializar un atributo en la declaración empleando el operador de asignación o la claúsula DEFAULT, del mismo modo que no se puede imponer la restricción NOT NULL. Sin embargo, los objetos se pueden almancenar en tablas de la base de datos en las que sí es posible imponer restricciones. </span></p>
<p style="text-align: justify;"><span><b> Métodos</b></span></p>
<p style="text-align: justify;"><span>En general, un método es un subprograma declarado en una especificación de tipo mediante la palabra </span>clave MEMBER. El método no puede tener el mismo nombre que el tipo de objeto ni el de ninguno de sus atributos.</p>
<p style="text-align: justify;"><span>Muchos métodos constan de dos partes: especificación y cuerpo. La especificación consiste en el </span>nombre del método, una lista opcional de parámetros y en el caso de funciones un tipo de retorno. El cuerpo es el código que se ejecuta para llevar a cabo una operación específica.<br />Para cada especificación de método en una especificación de tipo debe existir el correspondiente cuerpo del método. El PL/SQL compara la especificación del método y el cuerpo token a token, por lo que las cabeceras deben coincidir palabra a palabra.<br />En un tipo de objeto, los métodos pueden hacer referencia a los atributos y a los otros métodos sin <span>cualificador.  </span>Los métodos se pueden ejecutar sobre los objetos de su mismo tipo. Si x es una variable PL/SQL que <span>almacena objetos del tipo Cliente_T, entonces x.edad() calcula la edad del cliente almacenado en x. La definición del cuerpo de un método en PL/SQL se hace de la siguiente manera:</span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE OR REPLACE TYPE BODY cliente_t AS
MEMBER FUNCTION edad RETURN NUMBER IS
      a NUMBER;
       d DATE;
BEGIN
     d:= today();
     a:= d.año – fecha_nac.año;
IF (d.mes &lt; fecha_nac.mes) OR
((d.mes = fecha_nac.mes) AND (d.dia &lt; fecha_nac.dia))
    THEN a:= a-1;
END IF;
RETURN a;
END;
END;
 </code></pre>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span><b>El parámetro SELF</b></span></p>
<p style="text-align: justify;"><span>Todos los métodos de un tipo de objeto aceptan como primer parámetro una instancia predefinida </span>del mismo tipo denominada SELF. Independientemente de que se declare implicita o explícitamente, SELF es siempre el primer parámetro pasado a un método. Por ejemplo, el método transform declara SELF como un parámetro IN OUT:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE TYPE Complex AS OBJECT (
MEMBER FUNCTION transform  ( SELF IN OUT Complex ) . . .</code></pre>
</div>
</div>
<pre></pre>
</div>
</div>
</div>
<p style="text-align: justify;"><span>El modo de acceso por omisión de SELF, es decir, cuando no se declara explícitamente es:</span></p>
<ul style="text-align: justify;">
<li>En funciones miembro el acceso de SELF es IN.</li>
<li>En procedimientos, si SELF no se declara, su modo por omisión es IN OUT.</li>
</ul>
<p style="text-align: justify;"><span>En el cuerpo de un método, SELF denota al objeto a partir del cual se invocó el método. Como </span>muestra el siguiente ejemplo, los métodos pueden hacer referencia a los atributos de SELF sin necesidad de utilizar un cualificador:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<pre style="padding-left: 60px;"><code><span style="font-size: 10pt;"></span></code></pre>
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE FUNCTION gcd ( x INTEGER , y INTEGER ) RETURN INTEGER AS
-- Encuentra  el maximo comun divisor  de x e y
ans INTEGER;
BEGIN
IF x &lt; y THEN ans : = gcd ( x , y ) ;
ELSE ans : = gcd ( y , x MOD y ) ;
ENDIF ;
RETURN ans ;
END;
/
CREATE TYPE Rational AS
num INTEGER ,
den INTEGER ,
MEMBER PROCEDURE normalize ,
. . .
) ;
/
CREATE TYPE BODY Rational AS
 MEMBER PROCEDURE normalize IS
    g INTEGER;
 BEGIN
    --Estas dos sentencias son equivalentes
   g : = gcd ( SELF . num , SELF . den ) ;
   g : = gcd (num , den ) ;
   num : = num / g ;
   den : = den / g ;
 END normalize ;
. . .
END;
/</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span><b>Constructores</b></span></p>
<p style="text-align: justify;"><span>En Oracle, todos los tipos de objetos tienen asociado por defecto un método que construye nuevos </span><span>objetos de ese tipo de acuerdo a la especificación del tipo. El nombre del método coincide con el </span><span>nombre del tipo, y sus parámetros son los atributos del tipo. Por ejemplo las siguientes expresiones </span><span>construyen dos objetos con todos sus valores.</span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent"><b>direccion_t</b><span>('Avenida Sagunto', 'Puzol', 'Valencia', 'E-23523')</span><br /><span><b>cliente_t</b>( 2347, '</span><span>Juan Pérez Ruíz', </span><span><b>direccion_t</b>('Calle Eo', 'Onda', 'Castellón', '</span><span>34568'), '</span><span>696-779789', '</span><span>12/12/1981')</span></div>
<div class="editor-indent"><b style="font-size: 1.05em;"></b></div>
<div class="editor-indent"><b style="font-size: 1.05em;">Métodos de comparación</b></div>
</div>
<p style="text-align: justify;"><span>Para comparar los objetos de cierto tipo es necesario indicar a Oracle cuál es el criterio de </span>comparación. Para ello, hay que escoger entre un método MAP u ORDER, debiéndose definir al menos uno de estos métodos por cada tipo de objeto que necesite ser comparado. La diferencia entre ambos es la siguiente:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<ul>
<li><span>Un método MAP sirve para indicar cuál de los atributos del tipo se utilizará para ordenar los </span><span>objetos del tipo, y por tanto se puede utilizar para comparar los objetos de ese tipo por medio </span><span>de los operadores de comparación aritméticos (&lt;, &gt;).  <br />El PL/SQL usa esta función para evaluar expesiones booleanas como x &gt; y y para las comparaciones implícitas que requieren las claúsulas DISTINCT, GROUP BY y ORDER BY. Un tipo de objeto puede contener sólo una función de MAP, que necesariamente debe carecer de parámetros y debe devolver uno de los siguientes tipos escalares: DATE, NUMBER, VARCHAR2 y cualquiera de los tipos ANSI SQL (como CHARACTER o REAL). Por ejemplo, la siguiente declaración </span><span>permite decir que los objetos del tipo cliente_t se van a comparar por su atributo clinum.</span></li>
</ul>
</div>
</div>
</div>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE OR REPLACE TYPE BODY cliente_t AS
MAP MEMBER FUNCTION ret_value RETURN NUMBER IS
BEGIN
     RETURN clinum
END;
END;</code></pre>
</div>
</div>
</div>
</div>
<ul>
<li><span>Un método ORDER utiliza los atributos del objeto sobre el que se ejecuta para realizar un cálculo y compararlo con otro objeto del mismo tipo que toma como argumento de entrada. Este método devolverá un valor negativo si el parámetro de entrada es mayor que el atributo, un valor positivo si ocurre lo contrario y un cero si ambos son iguales. El siguiente ejemplo define un orden para el tipo cliente_t diferente al anterior. Sólo una de estas definiciones puede ser válida en un tiempo dado.</span></li>
</ul>
<span> </span></div>
</div>
</div>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>        CREATE TYPE cliente_t AS OBJECT (
        clinum NUMBER,
        clinomb VARCHAR2(200),
        direccion direccion_t,
        telefono VARCHAR2(20),
        fecha_nac DATE,
        ORDER MEMBER FUNCTION
        cli_ordenados (x IN clientes_t) RETURN INTEGER,

CREATE OR REPLACE TYPE BODY cliente_t AS
       ORDER MEMBER FUNCTION cli_ordenados (x IN cliente_t) RETURN INTEGER IS
BEGIN
       RETURN clinum - x.clinum; /*la resta de los dos números clinum*/
END;
END;</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>Veamos otro ejemplo: supongamos que c1 y c2 son objetos del tipo Customer. Una comparación del tipo c1 &gt; c2 invoca al método match automáticamente. El método devuelve un número negativo, cero o positivo que indica que SELF es respectivamente menor, igual o mayor que el otro parámetro:<br /></span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE TYPE Customer AS OBJECT (
      id NUMBER,
      name VARCHAR2( 2 0 ) ,
      addr VARCHAR2( 3 0 ) ,
      ORDER MEMBER FUNCTION match ( c Customer ) RETURN INTEGER
) ;
/
CREATE TYPE BODY Cus tomer AS
     ORDER MEMBER FUNCTION match ( c Cus tomer ) RETURN INTEGER IS
    BEGIN
         IF  id &lt; c .id THEN
              RETURN -1;
     --Cualquier numero negativo .
     ELSEIF  id &gt; c . id THEN
           RETURN 1 ;
      --cualquier numero positivo
     ELSE
          RETURN 0 ;
    END IF ;
  END;
END;
/</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>Un tipo de objeto puede contener un único método ORDER, que es una función que devuelve un resultado numérico. Es importante tener en cuenta los siguientes puntos:</span></p>
<ul style="text-align: justify;">
<li>Un método MAP proyecta el valor de los objetos en valores escalares (que son más fáciles de<span> </span><span>comparar). Un método ORDER simplemente compara el valor de un objeto con otro.</span></li>
<li>Se puede declarar un método MAP o un método ORDER, pero no ambos.</li>
<li>Si se declara uno de los dos métodos, es posible comparar objetos en SQL o en un procedimiento.</li>
<li>Cuando<span> es n</span><span>e</span><span>cesario ordenar</span><span> un número grande de objetos es mejor utilizar un método MAP (ya que una llamada por objeto proporciona una proyección escalar que es más fácil de ordenar). Un método ORDER es menos eficiente: debe invocarse repetidamente ya que compara sólo dos objetos cada vez</span></li>
</ul>
<p style="text-align: justify;"><span>Si un tipo de obje</span><span>to no tiene definido ninguno de estos métodos, Oracle es incapaz de deducir </span><span>cuándo un objeto es mayor o menor que otro.</span><br /><span>Sin embargo, sí puede determinar cuándo dos objetos del mismo tipo son iguales. Para ello, el sistema compara el valor de los atributos de los objetos uno </span><span>a uno:</span></p>
<ul style="text-align: justify;">
<li> Si todos los atributos son no nulos e iguales, Oracle indica que ambos objetos son iguales.</li>
<li> Si alguno de los atributos no nulos es distinto en los dos objetos, entonces Oracle dice que son diferentes.</li>
<li> En otro caso, Oracle d<span>ice que</span><span> no puede comparar ambos</span><span> objetos.</span></li>
</ul>
<p style="text-align: justify;"><span><b>Declaración e inicialización de objetos</b></span></p>
<p style="text-align: justify;"><span>Una vez que se ha definido un tipo de objeto y se ha instalado en el esquema de la base de  datos, es </span>posible usarlo en cualquier bloque PL/SQL. Las instancias de los objetos se crean en tiempo de ejecución. Estos objetos siguen las reglas normales de ámbito y de instanciación. En un bloque o subprograma, los objetos locales son instanciados cuando se entra en el bloque o subproprograma y dejan de existir cuando se sale. En un paquete, los objetos se instancian cuando se referencia por primera vez al paquete y dejan de existir cuando finaliza la sesión.</p>
<p style="text-align: justify;"><span><b> Declaración de objetos</b></span></p>
<p style="text-align: justify;"><span>Los tipos de objetos se declaran del mismo modo que cualquier tipo interno. Por ejemplo, en el bloque </span>que sigue se declara un objeto r de tipo Racional y se invoca al constructor para asignar su valor.<br />La llamada asigna los valores 6 y 8 a los atributos num y den respectivamente:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
r
Racional ;
BEGIN
r
: = Racional ( 6 , 8 ) ;
DBMS_OUTPUT.
PUT_LINE( r . num) ;
</code></pre>
</div>
</div>
<pre style="padding-left: 60px;"></pre>
</div>
</div>
<p style="text-align: justify;"><span>También es posible declarar objetos como parámetros formales de funciones y procedimientos, de modo que es posible pasar objetos a los subprogramas almacenados y de un subprograma a otro. En el siguiente ejemplo, se emplea un objeto de tipo Account para especificar el tipo de dato de un parámetro formal:<br /></span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
. . .
PROCEDURE open_act ( new_acct IN OUT Account ) IS . . .</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>y en el siguiente ejemplo se declara una función que devuelve un objeto de tipo Account:</span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
. . .
FUNCTION get_act&amp;nbsp;( act_id IN INTEGER ) RETURN Account IS . . .</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span><b>Inicialización de objetos</b></span></p>
<p style="text-align: justify;"><span>Hasta que se inicializa un objeto, invocando al constructor para ese tipo de objeto, el objeto se dice que es </span>Atómicamente nulo. Esto es, el objeto es nulo, no sólo sus atributos.</p>
<p style="text-align: justify;"><span>Un objeto nulo siempre es diferente a cualquier otro objeto. De hecho, la comparación de un objeto nulo con </span>otro objeto siempre resulta NULL. Del mismo modo, si se asigna un objeto con otro objeto atómicamente nulo, el primero se convierte a su vez en un objeto atómicamente nulo (y para poder utilizarlo debe ser reinicializado).</p>
<p style="text-align: justify;"><span>En resumen, si asignamos el no-valor NULL a un objeto, éste se convierte en atómicamente nulo, como se ilustra </span>en el siguiente ejemplo:</p>
<div class="highlighted-code language-sql" style="text-align: justify;">
<div>
<pre><code>DECLARE
r Racional ;
BEGIN
r Racional : = Racional ( 1 , 2 ) ; --r = 1 / 2
r : = NULL;--r atomicament e nulo
IF r IS NULL THEN . . .-- la condición resulta a TRUE</code></pre>
</div>
</div>
<pre style="padding-left: 60px;"></pre>
<p style="text-align: justify;"><span>Una buena práctica de programación consiste en inicializar los objetos en su declaración, como se muestra </span>en el siguiente ejemplo:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
r Racional : = Racional ( 2 , 3 ) ;--r = 2 / 3</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span><b>Objetos sin inicializar en PL/SQL</b></span></p>
<p style="text-align: justify;"><span>PL/SQL se comporta del siguiente modo cuando accede a objetos sin inicializar:</span></p>
<ul style="text-align: justify;">
<li> Los atributos de un objeto no inicializado se evalúan en cualquier expresión como NULL.</li>
<li>Intentar asignar valores a los atributos de un objeto sin inicializar provoca la excepción predefinida ACCESS_INTO_NULL.</li>
<li> La operación de comparación IS NULL siempre produce TRUE cuando se aplica a un objeto no inicializado o a cualquiera de sus atributos.</li>
</ul>
<p style="text-align: justify;"><span>Existe por tanto, una sutil diferencia entre objetos nulos y objetos con atributos nulos. El siguiente ejemplo </span><span>intenta ilustrar esa diferencia:</span></p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<pre style="padding-left: 60px;"><code><span style="font-size: 10pt;"></span></code></pre>
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
r Racional ;--r  es atomicamente nulo
BEGIN
IF r IS NULL THEN . . . --TRUE
IF r . num IS NULL THEN . . .--TRUE
r : = Racional (NULL , NULL) ; --Inicializar
r . num = 4 ;--Ex i t o : r ya no es atomicamente nulo aunque
--sus atributos  son nulos
r : = NULL;--r es de nuevo atomicamente nulo
r . num : = 4 ;--Provoca la excepcion ACCESS_INTO_NULL
EXCEPTION
WHEN ACCESS_INTO_NULL THEN
. . .
END;
/</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>La invocación de los métodos de un objeto no inicializado está permitida, pero en este caso: </span> SELF toma el valor NULL. Cuando los atributos de un objeto no inicializado se pasan como parámetros IN, se evalúan como NULL.  Cuando los atributos de un objeto no inicializado se pasan como parámetros OUT o IN OUT, se produce una excepción si se intenta asignarles un valor.</p>
<p style="text-align: justify;"><span><b>Acceso a los atributos</b></span></p>
<p style="text-align: justify;"><span>Para acceder o cambiar los valores de un atributo se emplea la notación punto (’.’). El siguiente ejemplo ilustra </span>esa notación:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>DECLARE
r RAcional : = Racional (NULL , NULL) ;
      numerador INTEGER;
      denominador INTEGER;
BEGIN
      . . .
     denominador : = r . den ;
     r . num = numerador ;</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>Los nombres de los atributos pueden encadenarse, lo que permite acceder a los atributos de un tipo de objeto </span>anidado. Por ejemplo, supongamos que definimos los tipos de objeto Address y Student como sigue:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>CREATE TYPE Address AS OBJECT (
street VARCHAR2( 30 ) ,
city VARCHAR2( 20 ) ,
state CHAR( 2 ) ,
zip_code VARCHAR2( 5 )
) ;
/
CREATE TYPE Student AS OBJECT (
name VARCHAR2( 20 ) ,
home_address Address ,
phone_number VARCHAR2( 10 ) ,
status VARCHAR2( 10 ) ,
advisor_name VARCHAR2( 20 ) ,
. . .
) ;
/</code></pre>
</div>
</div>
</div>
</div>
</div>
<p style="text-align: justify;"><span>Observe que zip_code es un atributo de tipo Address y que Address es el tipo de dato del atributo </span>home_address del tipo de objeto Student. Si s es un objeto Student, para acceder al valor de su zip_code se emplea la siguiente notación:</p>
<div class="editor-indent" style="text-align: justify;">
<div class="editor-indent">
<div class="editor-indent">
<div class="highlighted-code language-sql">
<div>
<pre><code>s . home_address . zip_code</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="elemento_centrado">
<div class="credenciales elemento_centrado" style="text-align: justify;"><span>Fuente: Departamento de Informática de la Universidad de Valencia.</span></div>
</div>
</div>
</div>
</article>
</section>
</div>
<div id='bottomPagination'>
<nav class="pagination noprt">
<a href="7_gestores_de_bases_de_datos_objetorelacionales.html" class="prev"><span><span>&laquo; </span>Anterior</span></a> <span class="sep">| </span><a href="72_tablas_de_objetos.html" class="next"><span>Siguiente<span> &raquo;</span></span></a>
</nav>
</div>
</div>
<script type="text/javascript" src="../js/_fpd_js.js"></script></body>
<!-- Mirrored from ead.murciaeduca.es/pluginfile.php/1431894/mod_resource/content/8/AD05_Contenidos_Web/71_tipos_de_objetos.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 15 Sep 2023 20:51:23 GMT -->
</html>